INSTR_	SRC, DEST	
     ^	 ^    ^		___寄存器:   %eax, %ebp
     |	 |____|_________|__立即数:   $123, $-1, $0x23, #1, ...
     |			|__内存引用: 0x007c0, ($esp), ...
后缀: b, w,  l , q	
      8  16  32  64

例如：
movb	movw	movl	movq

——————————————————————————————————————————————————————————————————————————————————————————————————————————
	intel					AT&T
      mov ax,12		     		     movw $12, %ax		move a word 12 to register(%) ax
						^
						|__:因为ax为16位寄存器，所以用 w 表示 16位

mov eax, DWORD PTR [0x007c0]		     movl 0x007c0, %eax

     cmp eax, ebx			     cmpl %eax, %ebx
     add eax, 1				     addl $1, %eax
——————————————————————————————————————————————————————————————————————————————————————————————————————————

什么是Multiboot？
一个相当成熟的Bootloader规范(家喻户晓的GRUB便是这个标准的一个实现)

省去了相当的麻烦：比如加载内核，开启A20总线(Tricky!)，进入保护模式

允许我们直接进入内核开发！！！


默认
-----------------------------------------------
已定义
%EAX = 0x2BADB002
%EBX = Bootloader 信息表
物理地址

%{C|D|E|F|G}S = 0x0	;段寄存器

A20 : 已打开

%CR0 = (%CR0 & 0x7FFFFFFF) | 0x1	CR0寄存器 的 最高为清零(0) 最低位为1 也就是PE = 1， PG = 0

%EFLAGS = %EFLAGS & 0xFFFEFEFF		IF = VM = 0 (关闭所有中断)
-----------------------------------------------
未定义

%ESP : 调用栈地址(非常重要!!)

%GDTR, %IDTR : 描述表，中断表

WARN! : GDTR未初始化！在我们设定他之前，避免对 %{C|D|E|F|G}S 段寄存器 的操作！否则会引发#GP异常，进而导致Triple Fault

-----------------------------------------------

boot.S之所以用大写S是因为代表这要通过GCC工具链来处理引用到C语言多的宏定义部分，小写s则代表是纯汇编
